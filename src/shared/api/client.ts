// @ts-nocheck

// Authentication API 1.0.0
// ---
// This file is automatically generated by openapi with preset effector-openapi-preset
// Do not edit this file directly. Instead open openapi config file and follow the link in "file"
import { createEffect } from 'effector';
import * as typed from 'typed-contracts';
import { requestFx } from './request';

//#region prebuilt code
const custom = { any: (valueName: string, value: unknown): any => value }

export type GenericErrors =
  | {
      status: 'unexpected';
      error: Error;
    }
  | {
      status: 'unknown_status';
      error: { status: number; body: unknown };
    }
  | {
      status: 'validation_error';
      error: typed.ValidationError;
    };

type ErrorCodes = 400 | 401 | 402 | 403 | 404 | 405 | 406 | 500 | 501 | 502 | 503 | 504 | 505;
/**
 * @throws
 */
function parseByStatus<
  Variants extends string,
  Contracts extends Record<number, [Variants, typed.Contract<any>]>,
  Result extends {
    [Code in keyof Contracts]: Contracts[Code] extends [infer Status, typed.Contract<infer T>]
      ? { status: Status; answer: T }
      : never;
  }
>(
  name: string,
  response: { status: number; body?: unknown },
  contracts: Contracts,
): Result[Exclude<keyof Result, ErrorCodes>] {
  const contractObject = contracts[response.status];
  if (!contractObject) {
    throw {
      status: 'unknown_status',
      error: {
        status: response.status,
        body: response.body,
      },
    };
  }
  const [status, contract] = contractObject;
  const answer = contract(name, response.body);
  if (answer instanceof typed.ValidationError) {
    throw { status: 'validation_error', error: answer };
  }
  if (response.status >= 400) {
    throw { status, error: answer };
  }
  return { status, answer } as Result[Exclude<keyof Result, ErrorCodes>];
}

function convertBodyToUrlSearchParams(body: Record<string, any>): URLSearchParams {
  function flattenObject(obj: any, parent: string = '', res: Record<string, string> = {}): Record<string, string> {
    for (let key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        const propName = parent ? `${parent}[${key}]` : key;
        if (typeof obj[key] === 'object' && obj[key] !== null && !Array.isArray(obj[key])) {
          flattenObject(obj[key], propName, res);
        } else {
          res[propName] = String(obj[key]);
        }
      }
    }
    return res;
  }

  const flatBody = flattenObject(body);
  return new URLSearchParams(flatBody);
}

//#endregion prebuilt code/* --- */
//#region authLoginPost
export type AuthLoginPost = {
  body: {
    email: string;
    password: string;
  };
};
/* Authentication successful (TFA not enabled) */
export const authLoginPostOk = typed.object({
  /* JWT Bearer token for authenticated requests */access_token: typed.string.optional,
  token_type: typed.string.optional,
  /* Token lifetime in seconds */expires_in: typed.number.optional
});
/* TFA required to complete login */
export const authLoginPostAccepted = typed.object({
  tfa_required: typed.boolean.optional,
  /* Temporary session ID to be used in the TFA verification step */tfa_session_id: typed.string.optional,
  message: typed.string.optional
});
export type AuthLoginPostDone = {
  status: "ok";
  answer: typed.Get<typeof authLoginPostOk>;
} | {
  status: "accepted";
  answer: typed.Get<typeof authLoginPostAccepted>;
};
/* Bad request (e.g., missing or invalid fields) */
export const authLoginPostBadRequest = typed.object({
  /* Human-readable error message */error: typed.string.optional,
  /* Machine-readable error code */code: typed.string.optional
});
/* Invalid credentials (wrong email or password) */
export const authLoginPostUnauthorized = typed.object({
  /* Human-readable error message */error: typed.string.optional,
  /* Machine-readable error code */code: typed.string.optional
});
/* Too many login attempts (rate limited) */
export const authLoginPostTooManyRequests = typed.object({
  /* Human-readable error message */error: typed.string.optional,
  /* Machine-readable error code */code: typed.string.optional
});
/* Internal server error */
export const authLoginPostInternalServerError = typed.object({
  /* Human-readable error message */error: typed.string.optional,
  /* Machine-readable error code */code: typed.string.optional
});
export type AuthLoginPostFail = {
  status: "bad_request";
  error: typed.Get<typeof authLoginPostBadRequest>;
} | {
  status: "unauthorized";
  error: typed.Get<typeof authLoginPostUnauthorized>;
} | {
  status: "too_many_requests";
  error: typed.Get<typeof authLoginPostTooManyRequests>;
} | {
  status: "internal_server_error";
  error: typed.Get<typeof authLoginPostInternalServerError>;
} | GenericErrors;
/* Authenticates the user with email and password.
 * If the user has TFA enabled, returns a `tfa_required` response with a `tfa_session_id`.
 * Otherwise, returns a JWT access token. */
export const authLoginPostFx = createEffect<AuthLoginPost, AuthLoginPostDone, AuthLoginPostFail>({
  async handler({
    body
  }) {
    const name = "authLoginPostFx.body";
    const response = await requestFx({
      path: "/auth/login",
      method: "POST",
      body
    });
    return parseByStatus(name, response, {
      200: ["ok", authLoginPostOk],
      202: ["accepted", authLoginPostAccepted],
      400: ["bad_request", authLoginPostBadRequest],
      401: ["unauthorized", authLoginPostUnauthorized],
      429: ["too_many_requests", authLoginPostTooManyRequests],
      500: ["internal_server_error", authLoginPostInternalServerError]
    });
  }
});
//#endregion authLoginPost

/* --- */
//#region authLoginTfaPost
export type AuthLoginTfaPost = {
  body: {
    /* Session ID returned from the initial login request */tfa_session_id: string;
    /* One-time password (usually 6 digits) */tfa_code: string;
  };
};
/* TFA verification successful; login completed */
export const authLoginTfaPostOk = typed.object({
  /* JWT Bearer token for authenticated requests */access_token: typed.string.optional,
  token_type: typed.string.optional,
  /* Token lifetime in seconds */expires_in: typed.number.optional
});
export type AuthLoginTfaPostDone = {
  status: "ok";
  answer: typed.Get<typeof authLoginTfaPostOk>;
};
/* Bad request (e.g., missing fields, invalid TFA code format) */
export const authLoginTfaPostBadRequest = typed.object({
  /* Human-readable error message */error: typed.string.optional,
  /* Machine-readable error code */code: typed.string.optional
});
/* Invalid or expired TFA session, or incorrect TFA code.
 * After too many failed attempts, the session may be invalidated. */
export const authLoginTfaPostUnauthorized = typed.object({
  /* Human-readable error message */error: typed.string.optional,
  /* Machine-readable error code */code: typed.string.optional
});
/* TFA session not found (e.g., already used or expired) */
export const authLoginTfaPostNotFound = typed.object({
  /* Human-readable error message */error: typed.string.optional,
  /* Machine-readable error code */code: typed.string.optional
});
/* Too many TFA attempts (rate limited) */
export const authLoginTfaPostTooManyRequests = typed.object({
  /* Human-readable error message */error: typed.string.optional,
  /* Machine-readable error code */code: typed.string.optional
});
/* Internal server error */
export const authLoginTfaPostInternalServerError = typed.object({
  /* Human-readable error message */error: typed.string.optional,
  /* Machine-readable error code */code: typed.string.optional
});
export type AuthLoginTfaPostFail = {
  status: "bad_request";
  error: typed.Get<typeof authLoginTfaPostBadRequest>;
} | {
  status: "unauthorized";
  error: typed.Get<typeof authLoginTfaPostUnauthorized>;
} | {
  status: "not_found";
  error: typed.Get<typeof authLoginTfaPostNotFound>;
} | {
  status: "too_many_requests";
  error: typed.Get<typeof authLoginTfaPostTooManyRequests>;
} | {
  status: "internal_server_error";
  error: typed.Get<typeof authLoginTfaPostInternalServerError>;
} | GenericErrors;
/* Submits the TFA code (e.g., 6-digit OTP) to complete authentication.
 * Requires a valid `tfa_session_id` from the `/auth/login` response. */
export const authLoginTfaPostFx = createEffect<AuthLoginTfaPost, AuthLoginTfaPostDone, AuthLoginTfaPostFail>({
  async handler({
    body
  }) {
    const name = "authLoginTfaPostFx.body";
    const response = await requestFx({
      path: "/auth/login/tfa",
      method: "POST",
      body
    });
    return parseByStatus(name, response, {
      200: ["ok", authLoginTfaPostOk],
      400: ["bad_request", authLoginTfaPostBadRequest],
      401: ["unauthorized", authLoginTfaPostUnauthorized],
      404: ["not_found", authLoginTfaPostNotFound],
      429: ["too_many_requests", authLoginTfaPostTooManyRequests],
      500: ["internal_server_error", authLoginTfaPostInternalServerError]
    });
  }
});
//#endregion authLoginTfaPost

